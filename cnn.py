import codecs
from pydoc import describe
import time, array
import numpy as np
import os, sys
import imageio
import cv2
from tqdm import tqdm_notebook as tqdm
from PIL import Image
import keras
from keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dropout, Dense, LSTM, TimeDistributed, RepeatVector, BatchNormalization
from keras.models import Model, Sequential
from keras import regularizers
# from tensorflow.keras import layers, models 
# from tensorflow.keras.optimizers import Adam
import PIL.Image as Image
from keras.preprocessing import image
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

def convert_asm_to_images(sourcepath, destpath):
    start_time=time.time()
    files=os.listdir(sourcepath)
    print('SourcePath: ',sourcepath)
    print('Destination path', destpath)
    print('converting..')
    for file in tqdm(files):
        filepath = sourcepath + "/" + file
        f=codecs.open(filepath,'rb')
        ln=os.path.getsize(filepath)
        width=64
        rem=int(ln/width)
        a=array.array("B")
        a.frombytes(f.read())
        f.close()
        g=np.reshape(a[:width*width], (width,width))
        g=np.uint8(g)
        imageio.imwrite(destpath+"/"+file +'.png', g)
    print('Files converte successfully')
    print('Time take to converte file: ',(time.time()-start_time)/3600)

def create_dir(directory):
    try:
        if not (os.path.exists(directory)):
            os.makedirs(directory)
    except OSError:
        if not os.path.isdir(directory):
            raise

size = 256, 256 #바꾸고 싶은 사이즈


def resize_and_crop(img_path, size, crop_type='middle'):
    
    files = os.listdir(img_path)
    
    for file in files: 
        
        name = img_path + "/" + file
        cnn_name = str(file)+"_cnn.png"
        os.chdir(img_path)
        img = Image.open(file)
        img_ratio = img.size[0] / float(img.size[1])
        ratio = size[0] / float(size[1])
        
        if ratio > img_ratio:
            img = img.resize((size[0], int(round(size[0] * img.size[1] / img.size[0]))),
                Image.ANTIALIAS)     
            if crop_type == 'top':
                box = (0, 0, img.size[0], size[1])
            elif crop_type == 'middle':
                box = (0, int(round((img.size[1] - size[1]) / 2)), img.size[0],
                    int(round((img.size[1] + size[1]) / 2)))
            elif crop_type == 'bottom':
                box = (0, img.size[1] - size[1], img.size[0], img.size[1])
            else :
                raise ValueError('ERROR: invalid value for crop_type')
            img = img.crop(box)
            
        elif ratio < img_ratio:
            img = img.resize((int(round(size[1] * img.size[0] / img.size[1])), size[1]),
                Image.ANTIALIAS)
            if crop_type == 'top':
                box = (0, 0, size[0], img.size[1])
            elif crop_type == 'middle':
                box = (int(round((img.size[0] - size[0]) / 2)), 0,
                    int(round((img.size[0] + size[0]) / 2)), img.size[1])
            elif crop_type == 'bottom':
                box = (img.size[0] - size[0], 0, img.size[0], img.size[1])
            else :
                raise ValueError('ERROR: invalid value for crop_type')
            img = img.crop(box)
            
        else :
            img = img.resize((size[0], size[1]), Image.ANTIALIAS)
            
        os.chdir(img_path)
        img.save(cnn_name, "PNG")
        os.remove(name)

def cnn_model():
    model = keras.models.Sequential()
    model.add(Conv2D(filters = 128, kernel_size = (5,5), activation= 'relu', input_shape = (256, 256, 3)))
    model.add(MaxPooling2D(pool_size = (2,2), strides = (1,1)))
    model.add(Dropout(0.2))

    model.add(Conv2D(64, (3,3), activation='relu'))
    model.add(MaxPooling2D(pool_size=(2,2), strides = (1,1), padding='same'))
    model.add(Dropout(0.2))

    model.add(Conv2D(32, (3,3), activation = 'relu'))
    model.add(MaxPooling2D(pool_size = (2,2), strides=(1,1), padding='same'))
    model.add(Dropout(0.2))

    model.add(Conv2D(28, (2,2), activation = 'relu'))
    model.add(MaxPooling2D(pool_size = (2,2), strides=(1,1), padding='same'))
    model.add(Dropout(0.2))

    model.add(Flatten())
    model.add(Dense(128, activation = 'relu'))
    model.add(Dense(64, activation = 'relu'))
    model.add(Dense(32, activation = 'relu'))
    model.add(Dense(1, activation = 'sigmoid'))
    return model




dest_list = ["test_benign", "test_malware", "valid_benign", "valid_malware", "train_benign", "train_malware", "test", "valid", "train"]
dir_path = os.path.dirname(os.path.realpath(__file__))
in_path = os.listdir(dir_path)

# directory Create
for i in range(6,8):
    destdir = os.path.join(dir_path, dest_list[i])
    create_dir(destdir)

test_dir = dir_path + "/test/"
valid_dir = dir_path + "/valid/"
train_dir = dir_path + "/train/"
create_dir(test_dir + dest_list[0])
create_dir(test_dir + dest_list[1])
create_dir(valid_dir + dest_list[2])
create_dir(valid_dir + dest_list[3])
create_dir(train_dir + dest_list[4])
create_dir(train_dir + dest_list[5])

# Image Create & Resize
for sourcepath in in_path:
    image_path = os.path.join(dir_path,sourcepath)
    if os.path.isdir(image_path):
        if sourcepath == "test_0":
            destpath = os.path.join(test_dir, dest_list[0])
            convert_asm_to_images(image_path, destpath)
            resize_and_crop(destpath,size)
        elif (sourcepath == "test_1"):
            destpath = os.path.join(test_dir, dest_list[1])
            convert_asm_to_images(image_path, destpath)
            resize_and_crop(destpath,size)
        elif (sourcepath == "valid_0"):   
            destpath = os.path.join(valid_dir, dest_list[2])
            convert_asm_to_images(image_path, destpath)
            resize_and_crop(destpath,size)
        elif (sourcepath == "valid_1"):
            destpath = os.path.join(valid_dir, dest_list[3])
            convert_asm_to_images(image_path, destpath)
            resize_and_crop(destpath,size)
        elif (sourcepath == "train_0"):
            destpath = os.path.join(train_dir, dest_list[4])
            convert_asm_to_images(image_path, destpath)
            resize_and_crop(destpath,size)
        elif (sourcepath == "train_1"):
            destpath = os.path.join(train_dir, dest_list[5])
            convert_asm_to_images(image_path, destpath)
            resize_and_crop(destpath,size)


# CNN 코드
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256
IMAGE_SHAPE = (IMAGE_WIDTH, IMAGE_HEIGHT)
BATCH_SIZE = 16

train_gen = image.ImageDataGenerator(horizontal_flip = True,
                              rotation_range = 35,
                              rescale = 1./255,
                              zoom_range = [0.7,1.5],
                              brightness_range = (0.7,1.0),
                              width_shift_range = 0.1,
                              height_shift_range = 0.1) 

VT_gen = image.ImageDataGenerator(rescale = 1./255)

batch_size = 16
# 실제 경로만 맞춰주면 됨.
dir_path = os.path.dirname(os.path.realpath(__file__))
train_genorator = VT_gen.flow_from_directory(dir_path+"/train/", target_size = IMAGE_SHAPE, batch_size = batch_size , class_mode='binary')
val_genorator = VT_gen.flow_from_directory(dir_path+"/valid/", shuffle = False, target_size = IMAGE_SHAPE, batch_size = batch_size, class_mode='binary')
test_genorator = VT_gen.flow_from_directory(dir_path+"/test/", shuffle = False, target_size = IMAGE_SHAPE, batch_size = batch_size, class_mode='binary')

print(train_genorator)

model = cnn_model()
model.compile(loss='binary_crossentropy', optimizer = 'adam', metrics=['accuracy'])
print("="*30)
print("model shape")
print("="*30)
print(model.summary())

print("[>] fitting start!!!!")
history = model.fit(train_genorator, epochs = 1, validation_data = val_genorator)

# To graph
# accurany to graph
acc_train = history.history['accuracy']
acc_val = history.history['val_accuracy']
epochs = range(1,11)
plt.plot(epochs, acc_train, 'g', label='Training accuracy')
plt.plot(epochs, acc_val, 'b', label='validation accuracy')
plt.title('Training and Validation accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

# loss to graph
loss_train = history.history['loss']
loss_val = history.history['val_loss']
epochs = range(1,11)
plt.plot(epochs, loss_train, 'g', label='Training loss')
plt.plot(epochs, loss_val, 'b', label='validation loss')
plt.title('Training and Validation loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

print("[>] check start!!!!")
X_pred = model.predict(test_genorator)
X_accurancy=model.evaluate(test_genorator)
print("pred :",X_pred)
print("accurancy :",X_accurancy)
model.save('cnn1.h5')